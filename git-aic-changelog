#!/bin/bash

# =============================================================================
# git-aic-changelog - GitHub Release Changelog Generator
# Companion tool for git-aic
# =============================================================================

set -e

VERSION="1.0.0"

# =============================================================================
# CONFIGURATION
# =============================================================================

get_config() {
  local key="$1"
  local default="$2"
  git config --get "commit-ai.$key" 2>/dev/null || echo "$default"
}

GITHUB_TOKEN=$(get_config "github-token" "${GITHUB_TOKEN:-}")
API_KEY=$(get_config "api-key" "")
PROVIDER=$(get_config "provider" "gemini")
MODEL=$(get_config "model" "gemini-2.0-flash-exp")

# =============================================================================
# HELP
# =============================================================================

show_help() {
  cat << EOF
git-aic-changelog v$VERSION - GitHub Release Changelog Generator

USAGE:
  git-aic-changelog [OPTIONS] [TAG]

OPTIONS:
  -h, --help              Show this help
  -v, --version           Show version
  -d, --dry-run           Preview without creating release
  -l, --latest            Generate from latest tag
  -r, --range START..END  Generate from commit range
  --draft                 Create as draft release
  --prerelease            Mark as pre-release
  --ai                    Use AI to enhance changelog
  --setup                 Setup GitHub token

EXAMPLES:
  # Generate changelog for latest tag
  git-aic-changelog --latest

  # Generate for specific tag
  git-aic-changelog v1.2.0

  # Generate from commit range
  git-aic-changelog --range v1.0.0..v1.2.0

  # Preview without publishing
  git-aic-changelog --latest --dry-run

  # Create draft release with AI enhancement
  git-aic-changelog v2.0.0 --draft --ai

CONFIGURATION:
  # GitHub Personal Access Token (required)
  git config --global commit-ai.github-token "ghp_xxxxx"
  # Or set environment variable:
  export GITHUB_TOKEN="ghp_xxxxx"

  # Get token from: https://github.com/settings/tokens
  # Required scopes: repo (full control)

MORE INFO:
  https://github.com/ardelagi/git-aic
EOF
}

setup_wizard() {
  echo "=== GitHub Changelog Setup ==="
  echo ""
  echo "You need a GitHub Personal Access Token."
  echo "Get one from: https://github.com/settings/tokens"
  echo "Required scope: 'repo' (Full control of private repositories)"
  echo ""
  read -p "Enter your GitHub token: " token
  
  if [ -z "$token" ]; then
    echo "âŒ Token cannot be empty"
    exit 1
  fi
  
  git config --global commit-ai.github-token "$token"
  
  echo ""
  echo "âœ“ Token saved!"
  echo ""
  echo "You can now use: git-aic-changelog --latest"
  exit 0
}

# =============================================================================
# VALIDATION
# =============================================================================

validate_environment() {
  # Check git repo
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "âŒ Error: Not a git repository"
    exit 1
  fi
  
  # Check GitHub token
  if [ -z "$GITHUB_TOKEN" ]; then
    echo "âŒ Error: GitHub token not configured"
    echo ""
    echo "Run: git-aic-changelog --setup"
    echo "Or: git config --global commit-ai.github-token YOUR_TOKEN"
    echo "Or: export GITHUB_TOKEN=YOUR_TOKEN"
    exit 1
  fi
  
  # Check required commands
  for cmd in git curl jq; do
    if ! command -v $cmd &> /dev/null; then
      echo "âŒ Error: Required command not found: $cmd"
      exit 1
    fi
  done
  
  # Check remote
  if ! git remote get-url origin &> /dev/null; then
    echo "âŒ Error: No git remote 'origin' configured"
    exit 1
  fi
}

# =============================================================================
# GITHUB API
# =============================================================================

get_repo_info() {
  local remote_url=$(git remote get-url origin)
  
  # Extract owner/repo from various URL formats
  # SSH: git@github.com:user/repo.git
  # HTTPS: https://github.com/user/repo.git
  if echo "$remote_url" | grep -q "github.com"; then
    REPO_OWNER=$(echo "$remote_url" | sed -E 's/.*github\.com[:/]([^/]+)\/.*/\1/')
    REPO_NAME=$(echo "$remote_url" | sed -E 's/.*github\.com[:/][^/]+\/([^/]+)(\.git)?$/\1/' | sed 's/\.git$//')
  else
    echo "âŒ Error: Cannot parse GitHub repository from remote URL"
    exit 1
  fi
  
  echo "Repository: $REPO_OWNER/$REPO_NAME"
}

github_api() {
  local method="$1"
  local endpoint="$2"
  local data="$3"
  
  local url="https://api.github.com${endpoint}"
  
  if [ "$method" = "GET" ]; then
    curl -s -H "Authorization: token $GITHUB_TOKEN" \
         -H "Accept: application/vnd.github.v3+json" \
         "$url"
  else
    curl -s -X "$method" \
         -H "Authorization: token $GITHUB_TOKEN" \
         -H "Accept: application/vnd.github.v3+json" \
         -H "Content-Type: application/json" \
         -d "$data" \
         "$url"
  fi
}

# =============================================================================
# COMMIT PARSING
# =============================================================================

get_commits_between() {
  local start="$1"
  local end="${2:-HEAD}"
  
  git log --pretty=format:"%H|%s|%b|%an|%ae|%ad" --date=short "$start..$end"
}

get_latest_tag() {
  git describe --tags --abbrev=0 2>/dev/null || echo ""
}

get_previous_tag() {
  local current_tag="$1"
  git describe --tags --abbrev=0 "$current_tag^" 2>/dev/null || echo ""
}

parse_commits() {
  local commits="$1"
  
  # Initialize arrays
  declare -A categories=(
    ["feat"]="## ğŸš€ Features"
    ["fix"]="## ğŸ› Bug Fixes"
    ["perf"]="## âš¡ Performance"
    ["refactor"]="## â™»ï¸ Refactoring"
    ["docs"]="## ğŸ“š Documentation"
    ["style"]="## ğŸ’„ Styles"
    ["test"]="## âœ… Tests"
    ["build"]="## ğŸ“¦ Build"
    ["ci"]="## ğŸ‘· CI/CD"
    ["chore"]="## ğŸ”§ Chores"
  )
  
  declare -A changes
  declare -a breaking_changes
  
  # Parse each commit
  while IFS='|' read -r hash subject body author email date; do
    # Extract type from conventional commit
    local type=""
    local scope=""
    local breaking=""
    local desc=""
    
    # Parse conventional commit format: type(scope)!: description
    if echo "$subject" | grep -qE '^[a-z]+(\([^)]+\))?!?:'; then
      type=$(echo "$subject" | sed -E 's/^([a-z]+).*/\1/')
      scope=$(echo "$subject" | sed -E 's/^[a-z]+\(([^)]+)\).*/\1/' | grep -v ':' || echo "")
      breaking=$(echo "$subject" | grep -o '!' || echo "")
      desc=$(echo "$subject" | sed -E 's/^[a-z]+(\([^)]+\))?!?:[[:space:]]*//')
      
      # Format commit line
      local short_hash="${hash:0:7}"
      local commit_line="- $desc ([${short_hash}](../../commit/$hash))"
      
      # Add to appropriate category
      if [ -n "${categories[$type]}" ]; then
        changes["$type"]+="$commit_line"$'\n'
      else
        changes["chore"]+="$commit_line"$'\n'
      fi
      
      # Check for breaking changes
      if [ -n "$breaking" ] || echo "$body" | grep -qi "BREAKING CHANGE"; then
        breaking_changes+=("- **BREAKING**: $desc ([${short_hash}](../../commit/$hash))")
      fi
    else
      # Non-conventional commit
      local short_hash="${hash:0:7}"
      changes["chore"]+="- $subject ([${short_hash}](../../commit/$hash))"$'\n'
    fi
  done <<< "$commits"
  
  # Build changelog
  local changelog=""
  
  # Breaking changes first
  if [ ${#breaking_changes[@]} -gt 0 ]; then
    changelog+="## âš ï¸ BREAKING CHANGES"$'\n\n'
    for change in "${breaking_changes[@]}"; do
      changelog+="$change"$'\n'
    done
    changelog+=$'\n'
  fi
  
  # Other categories
  for type in feat fix perf refactor docs style test build ci chore; do
    if [ -n "${changes[$type]}" ]; then
      changelog+="${categories[$type]}"$'\n\n'
      changelog+="${changes[$type]}"$'\n'
    fi
  done
  
  echo "$changelog"
}

# =============================================================================
# AI ENHANCEMENT
# =============================================================================

generate_gemini() {
  local prompt="$1"
  
  local json=$(jq -n --arg prompt "$prompt" '{
    contents: [
      { "role": "user", "parts": [{ "text": $prompt }] }
    ]
  }')
  
  local response=$(curl -s \
    -H "Content-Type: application/json" \
    -X POST \
    "https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent?key=${API_KEY}" \
    -d "$json")
  
  echo "$response" | jq -r '.candidates[0].content.parts[0].text // empty'
}

generate_openai() {
  local prompt="$1"
  
  local json=$(jq -n --arg prompt "$prompt" '{
    model: "gpt-4o-mini",
    messages: [
      { "role": "user", "content": $prompt }
    ],
    temperature: 0.7
  }')
  
  local response=$(curl -s \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer ${API_KEY}" \
    -X POST \
    "https://api.openai.com/v1/chat/completions" \
    -d "$json")
  
  echo "$response" | jq -r '.choices[0].message.content // empty'
}

generate_anthropic() {
  local prompt="$1"
  
  local json=$(jq -n --arg prompt "$prompt" '{
    model: "claude-3-5-sonnet-20241022",
    max_tokens: 2048,
    messages: [
      { "role": "user", "content": $prompt }
    ]
  }')
  
  local response=$(curl -s \
    -H "Content-Type: application/json" \
    -H "x-api-key: ${API_KEY}" \
    -H "anthropic-version: 2023-06-01" \
    -X POST \
    "https://api.anthropic.com/v1/messages" \
    -d "$json")
  
  echo "$response" | jq -r '.content[0].text // empty'
}

enhance_with_ai() {
  local changelog="$1"
  local tag="$2"
  
  if [ -z "$API_KEY" ]; then
    echo "âš ï¸  AI enhancement skipped (no API key configured)"
    echo "$changelog"
    return
  fi
  
  echo "ğŸ¤– Enhancing changelog with AI..."
  
  local prompt="You are a technical writer creating release notes.

Given this auto-generated changelog, enhance it with:
1. A brief, engaging release summary (2-3 sentences)
2. Highlight the most important changes
3. Keep all the existing commit links and structure
4. Make it professional and user-friendly

Tag: $tag

Changelog:
$changelog

Return the enhanced changelog in the same markdown format."

  case $PROVIDER in
    gemini)
      generate_gemini "$prompt"
      ;;
    openai)
      generate_openai "$prompt"
      ;;
    anthropic)
      generate_anthropic "$prompt"
      ;;
    *)
      echo "$changelog"
      ;;
  esac
}

# =============================================================================
# RELEASE CREATION
# =============================================================================

create_github_release() {
  local tag="$1"
  local changelog="$2"
  local draft="$3"
  local prerelease="$4"
  
  # Prepare release data
  local release_data=$(jq -n \
    --arg tag "$tag" \
    --arg name "$tag" \
    --arg body "$changelog" \
    --argjson draft "$draft" \
    --argjson prerelease "$prerelease" \
    '{
      tag_name: $tag,
      name: $name,
      body: $body,
      draft: $draft,
      prerelease: $prerelease
    }')
  
  echo "ğŸ“¤ Creating GitHub release..."
  
  local response=$(github_api "POST" "/repos/$REPO_OWNER/$REPO_NAME/releases" "$release_data")
  
  if echo "$response" | jq -e '.id' > /dev/null 2>&1; then
    local html_url=$(echo "$response" | jq -r '.html_url')
    echo "âœ… Release created successfully!"
    echo "ğŸ”— $html_url"
  else
    echo "âŒ Error creating release:"
    echo "$response" | jq -r '.message // .'
    exit 1
  fi
}

# =============================================================================
# MAIN
# =============================================================================

main() {
  local tag=""
  local dry_run=false
  local use_latest=false
  local commit_range=""
  local draft=false
  local prerelease=false
  local use_ai=false
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      -h|--help)
        show_help
        exit 0
        ;;
      -v|--version)
        echo "git-aic-changelog v$VERSION"
        exit 0
        ;;
      --setup)
        setup_wizard
        ;;
      -d|--dry-run)
        dry_run=true
        shift
        ;;
      -l|--latest)
        use_latest=true
        shift
        ;;
      -r|--range)
        commit_range="$2"
        shift 2
        ;;
      --draft)
        draft=true
        shift
        ;;
      --prerelease)
        prerelease=true
        shift
        ;;
      --ai)
        use_ai=true
        shift
        ;;
      *)
        tag="$1"
        shift
        ;;
    esac
  done
  
  # Validate
  validate_environment
  
  # Get repository info
  get_repo_info
  
  echo ""
  
  # Determine tag and range
  if [ "$use_latest" = true ]; then
    tag=$(get_latest_tag)
    if [ -z "$tag" ]; then
      echo "âŒ Error: No tags found in repository"
      exit 1
    fi
    local prev_tag=$(get_previous_tag "$tag")
    if [ -z "$prev_tag" ]; then
      commit_range="$(git rev-list --max-parents=0 HEAD)..HEAD"
    else
      commit_range="$prev_tag..$tag"
    fi
  elif [ -n "$commit_range" ]; then
    if [ -z "$tag" ]; then
      tag=$(echo "$commit_range" | cut -d'.' -f3-)
    fi
  elif [ -n "$tag" ]; then
    local prev_tag=$(get_previous_tag "$tag")
    if [ -z "$prev_tag" ]; then
      commit_range="$(git rev-list --max-parents=0 HEAD)..$tag"
    else
      commit_range="$prev_tag..$tag"
    fi
  else
    echo "âŒ Error: No tag or range specified"
    echo "Use: --latest, --range START..END, or specify a tag"
    exit 1
  fi
  
  echo "ğŸ“‹ Generating changelog for: $tag"
  echo "ğŸ“Š Commit range: $commit_range"
  echo ""
  
  # Get commits
  local start_ref=$(echo "$commit_range" | cut -d'.' -f1)
  local end_ref=$(echo "$commit_range" | cut -d'.' -f3-)
  
  echo "ğŸ” Analyzing commits..."
  local commits=$(get_commits_between "$start_ref" "$end_ref")
  
  if [ -z "$commits" ]; then
    echo "âš ï¸  No commits found in range"
    exit 0
  fi
  
  # Parse commits into changelog
  local changelog=$(parse_commits "$commits")
  
  # Add header
  local commit_count=$(echo "$commits" | wc -l)
  local full_changelog="# Release $tag

**Full Changelog**: https://github.com/$REPO_OWNER/$REPO_NAME/compare/$start_ref...$end_ref

$changelog

---

**$commit_count commits** in this release"

  # Enhance with AI if requested
  if [ "$use_ai" = true ]; then
    full_changelog=$(enhance_with_ai "$full_changelog" "$tag")
  fi
  
  # Show preview
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "$full_changelog"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
  
  # Dry run mode
  if [ "$dry_run" = true ]; then
    echo "ğŸ” Dry run mode - no release created"
    exit 0
  fi
  
  # Confirm
  read -p "Create GitHub release? (y/n): " confirm
  if [ "$confirm" != "y" ]; then
    echo "âŒ Release cancelled"
    exit 0
  fi
  
  # Create release
  create_github_release "$tag" "$full_changelog" "$draft" "$prerelease"
}

main "$@"
